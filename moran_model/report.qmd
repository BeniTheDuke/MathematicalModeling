---
title: "The Moran model: Fixation time of beneficial alleles in populations of constant size"
author: "Eleni Karfopoulou & Benjamin Herzog"
format:
  html:
    toc: true
    number-sections: true
  pdf:
    number-sections: true
    header-includes:
      - \usepackage{wrapfig}
      - \usepackage{graphicx}
      - \usepackage{subfig}
      - \usepackage{caption}
    documentclass: scrreprt
    geometry:
      - left=15mm
      - right=15mm
      - top=20mm
      - bottom=20mm
      - foot=10mm
execute:
  echo: true
  warning: false
  message: false
---
```{=latex}
\cleardoublepage
\pagenumbering{arabic}
\setcounter{page}{1}
```

```{python}
#| echo: false
#| include: false

import numpy as np
from moran import MoranModel
import matplotlib.pyplot as plt
SEED = 42

```


# Definition of the Model

The Moran model is a birth-death Markov model used to study population dynamics in biology. In this particular model we study the distribution of alleles across generations when there is selection, i.e. a particular allele presents with increased (or decreased) fitness that affects its probability for reproduction, as opposed to the neutral drift model, when alleles reproduce at the same rate. Chapter 6 of *Nowak, 2006* is used as reference.

## Model assumptions:

-   The size of the population, *N*, is fixed.

-   There are two types of alleles of interest in the population, A and B. (For ease of reference, we will refer to the individuals -carrying those alleles- as A and B.)

-   [At every one time step]{.underline}, one random individual from the population is chosen to reproduce and one random individual is chosen to die. Sampling with replacement applies, i.e. it could be the same individual chosen for reproduction as well as death.

-   Reproduction leads to A producing A, and B producing B.

-   In a Moran model with selection, A has fitness *r* and B has fitness 1. If *r* \> 1, selection favors A; if *r* \< 1, selection favors B. (When *r* = 1, this is the case of neutral drift.)

## Model description:

-   The number of A individuals in the population is denoted *i*, and the number of B individuals is thus *N - i*. The state space of *i* is 0, …., *N*.

-   The probability of choosing an A individual for reproduction is *(r \* i) / \[r \* i + (N - i ) \* 1\] = (r \* i) / (r \* i + N - i)*.

-   The probability of choosing B for reproduction is *(N - i) / (r \* i + N - i)*.

-   The probability of choosing an A individual for death is *i/N*, for a B individual it is *(N - i)/N*.

-   In every time step there are four possible scenarios:

    -   With probability *\[(r \* i) / (r \* i + N - i)\] \* (i/N)*, an A is chosen for birth as well as death; *i* remains unchanged.

    -   With probability *\[(N - i) / (r \* i + N - i)\] \* (N - i)/N*, a B is chosen for birth as well as death; *i* remains unchanged.

    -   With probability *\[(r \* i) / (r \* i + N - i)\] \* (N - i)/N*, an A is chosen for birth and a B for death; *i* becomes *i + 1*.

    -   With probability *\[(N - i) / (r \* i + N - i)\] \* i/N*, a B is chosen for birth and an A for death; *i* becomes *i - 1*.

<!-- -->

-   The transition matrix from state *i* to state *j* is accordingly described by

    -   P~i, i-1~ = *\[(N - i) / (r \* i + N - i)\] \* i/N*

    -   P~i, i~ = *1 - P~i, i-1~ - P~i, i+1~*

    -   P~i, i+1~ = *\[(r \* i) / (r \* i + N - i)\] \* (N - i)/N*

-   No other transition is possible, thus all other entries are 0. Also, P~0, 0~ = 1, P~0, i~ = 0, P~N, N~ = 1 and P~N, 0~ = 0, i.e. 0 and *N* are absorbing states.

The **fixation probability** of A refers to the probability of reaching a state where *i = N*, i.e. A has overtaken the entire population. In this model with selection, with the relative fitness of A being *r*, the fixation probability, starting from *i* individuals of A, is:

$χ_i$ = (1 - 1/r^i^) / (1 - 1/r^N^)

-   If there is no selective advantage, starting with *i* individuals of A, the probability of A overtaking the entire *N* population is *i/N*.

-   If *r* \>1 in a large population *N*, the denominator approaches 1 and the equation approximates 1 - 1/r^i.^

-   If *r* \< 1, the numerator approaches 0 as *r* gets smaller.

## Model Simulation

Our program simulates a Moran population model with selection.
Running the simulation **for equal fitness**, the output graph displays the progression of i over time (steps) until either absorption or fixation:

```{python}
#| echo: false
moran_model = MoranModel(100, 50, 1, 1, SEED)
history = moran_model.run_until_absorption()
plt.figure(figsize=(9,4))
plt.plot(history)
plt.xlabel("Steps")
plt.ylabel("i", rotation=0)
plt.tight_layout()
plt.show()
moran_model = MoranModel(100, 50, 1, 1, SEED)

```

# Model Validation:


In a neutral model where fitness = 1 for both alleles, the fixation probability is i/N. If we run the model for 1000 runs, for N = 100, for different i, the observed fixation rate should approximate i/N. We have simulated this and compared the simulation results to the calculated probabilities. They are almost equal, as displayed in the graph below.

```{python}
#| echo: false
N = 100
n_of_experiments = 10 #todo change back to 1000


observed_probs = []
calculated_probs = []
i_list = range(0,101,10)

for i in i_list:
  moran_model = MoranModel(N, i, 1, 1, SEED)
  fix_prob = i/N
  count=[] # list of the end states of i
  for run in range(n_of_experiments):
    count.append(moran_model.run_until_absorption()[-1])
    obs_fix = (count.count(100))/n_of_experiments
  
  
  calculated_probs.append(fix_prob)
  observed_probs.append(obs_fix)
  
w = 0.3 # Width 
x = np.arange(len(i_list))
plt.figure()
plt.bar(x - w/2, calculated_probs, width=w, label="Calculated")
plt.bar(x + w/2, observed_probs, width=w, label="Simulated")
plt.xlabel("N")
plt.ylabel("Fixation Probability/Rate")
plt.xticks(x, i_list)
plt.legend()
plt.tight_layout()
plt.show()

```

Expanding the validation, we now check whether the observed fixation rate matches the expected fixation probability for different values r of fitness of A,
for all the different combinations of i from 10 to 90 with steps of 10, and r from 0.8 to 1.3 with steps of 0.1. As displayed in the graph below, indeed the simulated rates and the calculated probabilites are almost identical, hence validating our program. 

```{python}
#| echo: false
N = 100
n_of_experiments = 10 #todo change back to 1000

observed_probs = []
calculated_probs = []
i_list = range(10,91,10)
r_list = np.arange(0.8, 1.4, 0.1)

for i in i_list:
  for r in r_list:
    
    moran_model = MoranModel(N, i, r, 1, SEED)
    
    if r == 1:
      fix_prob = i/N
    else:
      fix_prob = (1 - 1/r**i)/(1 - 1/r**N)
    
    count=[] # list of the end states of i
    
    for run in range(n_of_experiments):
      count.append(moran_model.run_until_absorption()[-1])
    obs_fix = (count.count(100))/n_of_experiments

    calculated_probs.append(fix_prob)
    observed_probs.append(obs_fix)

calculated_probs = np.array(calculated_probs)
observed_probs   = np.array(observed_probs)

x = np.arange(len(calculated_probs))  
w = 0.35

plt.figure(figsize=(12, 4))
plt.bar(x - w/2, calculated_probs, width=w, label="Calculated")
plt.bar(x + w/2, observed_probs,   width=w, label="Simulated")

plt.xlabel("Experiments with different i and r\n (Note that some runs have a fixation probability/rate of 0)")
plt.xticks([])
plt.tick_params(axis="x", bottom=False)
plt.ylabel("Fixation Probability/Rate")
plt.legend()
plt.tight_layout()
plt.show() 

```

# Experiments


## Impact of N and i, with Equal Fitness
We are examining the behaviour of a model with equal fitness. Specifically how many steps it takes to reach absorption/fixation. We want to examine four different i-to-N ratios, over increasing Ns. 
  
As displayed by the graph below: In general the model takes more steps as N increases.    
A lower i-to-N ratio will decrease the required steps (at a given N). When going from a ratio of 1/2 to 1/4, the i is significantly reduced but the steps are only slightly reduced (Seen in the blue and green lines in the graph). We can even take it to the extreme and reduce i to 1, the most deleterious option for A without selection. Impressively the model still takes over 600 steps (at high Ns), even though there is a 50% chance that a run will end on the first step. 

```{python}
#| echo: false

amount_of_experiments = 100 # Todo: Increase to 1000
n_list = range(4, 105, 10)

average_steps_Nhalf = []
average_steps_Nhalf_minus1 = []
average_steps_Nquarter = []
average_steps_1 = []

for n in n_list:
  total_steps = 0
  moran_model = MoranModel(n, n/2, 1, 1, SEED)
  for i in range (amount_of_experiments):
    history = moran_model.run_until_absorption()
    total_steps += len(history)
  average_steps_Nhalf.append(total_steps/amount_of_experiments)

for n in n_list:
  total_steps = 0
  moran_model = MoranModel(n, (n/2) -1 , 1, 1, SEED)
  for i in range (amount_of_experiments):
    history = moran_model.run_until_absorption()
    total_steps += len(history)
  average_steps_Nhalf_minus1.append(total_steps/amount_of_experiments)

for n in n_list:
  total_steps = 0
  moran_model = MoranModel(n, (n/4) , 1, 1, SEED)
  for i in range (amount_of_experiments):
    history = moran_model.run_until_absorption()
    total_steps += len(history)
  average_steps_Nquarter.append(total_steps/amount_of_experiments)

for n in n_list:
  total_steps = 0
  moran_model = MoranModel(n, 1, 1, 1, SEED)
  for i in range (amount_of_experiments):
    history = moran_model.run_until_absorption()
    total_steps += len(history)
  average_steps_1.append(total_steps/amount_of_experiments)
plt.figure()
plt.plot(n_list, average_steps_Nhalf, label='i = N/2')
plt.plot(n_list, average_steps_Nhalf_minus1, label='i = (N/2) - 1')
plt.plot(n_list, average_steps_Nquarter, label='i = N/4')
plt.plot(n_list, average_steps_1, label='i = 1')
# --- Move Y-Axis to the right ---
ax = plt.gca()
ax.yaxis.tick_right()
ax.yaxis.set_label_position("right")
# --------------------------------
plt.xlabel("N")
plt.ylabel("Steps")
plt.legend()
plt.tight_layout()
plt.show()

```



## Can deleterious alleles get fixed in a population?

### Decreasing Fitness

Let's start by decreasing r and see whether there is still a chance for survival. 
We run simulations varying the fitness *r* in the range of 0.8 and 1.

```{python}
#| echo: false
fitness_list = np.arange(1, 0.8, -0.01)
n_of_experiments = 10 #todo increase to 1000
success_rates = []

for r in fitness_list:
  moran_model = MoranModel(100, 50, r, 1, SEED)
  successes = 0
  for _ in range(n_of_experiments):
    if(moran_model.run_until_absorption()[-1]>0):
      successes += 1
  success_rate = 100 / n_of_experiments * successes
  success_rates.append(success_rate)

plt.figure(figsize=(4,3))
plt.plot(fitness_list, success_rates)
plt.gca().invert_xaxis()
plt.xlabel("Fitness (r)")
plt.ylabel("Survival Rate (%)")
plt.tight_layout()
plt.savefig("_DecreasingFitness.pdf", bbox_inches="tight") #todo Remove bbox_inches if not necessary
plt.close()

```


\noindent
\begin{minipage}[t]{0.45\textwidth}
\centering
\vspace{0pt}
\includegraphics[width=\linewidth]{_DecreasingFitness.pdf}
\end{minipage}\hfill
\begin{minipage}[t]{0.5\textwidth}
\vspace{0pt}
We are examining the probability of A surviving as its fitness r decreases, for a given N population (here 100). 
Starting with fitness r = 1 the observed probability is as expected close to 50\%. 
As r decreases, the probability of A getting fixed decreases rapidly and approaches 0 for values of r smaller than 0.9. 
However, this graph draws from a finite numbers of experiments; 
theoretically, there is always a chance of survival in the case of infinite experiments.
\end{minipage}


### Increasing Initial Population
Let's continue with a decreased fitness of 0.9. Even if the survival chance is almost zero, we should be able to increase it by increasing the initial population of A (i).  
In parallel we also examine the impact of four different total populations *N*.


```{python}
#| echo: false
n_of_experiments = 5 #todo increase to 200

plt.figure(figsize=(4,3))

n_list = [100, 200, 300, 400]

for n in n_list:
  i_step_size = int(n/50)
  i_list = range(int(n/2), n + i_step_size, i_step_size)
  success_rates = []

  for i in i_list:
    moran_model = MoranModel(n, i, 0.9, 1, SEED)
    successes = 0
    for _ in range(n_of_experiments):
      if(moran_model.run_until_absorption()[-1]>0):
        successes += 1
    success_rate = 100 / n_of_experiments * successes
    success_rates.append(success_rate)

  i_list_as_percentage = [100 * i / n for i in i_list]
  plt.plot(i_list_as_percentage, success_rates, label=f"N = {n}")


plt.xlabel("Initial population i (% of N)")
plt.ylabel("Survival Rate (%)")
plt.legend()
plt.tight_layout()
plt.savefig("_IncreasingInitialPopulation.pdf", bbox_inches="tight")
plt.close()

```


\noindent
\begin{minipage}[t]{0.45\textwidth}
\centering
\vspace{0pt}
\includegraphics[width=\linewidth]{_IncreasingInitialPopulation.pdf}
\end{minipage}\hfill
\begin{minipage}[t]{0.5\textwidth}
\vspace{0pt}
Indeed the survival rate increases with increased initial population of A (i).
However, this effect diminishes when increasing the total population (N). 
\newline
\newline
Looking at a fixed point in i (e.g. 90\%) we can see that a higher N decreases the chance of the deleterious allele surviving. I.e. selection is more efficient in larger populations.  
\end{minipage}

To answer our question: Yes, a deleterious allele can get fixed in a population. As presented by the experiments above, the conditions that increase the probability of surviving are:
- A larger r (while still being deleterious, i.e. below 1)
- Smaller total population N
- Higher initial population i in respect to N


# Discussion



Drawing from the simulations and graphs presented and discussed above, we can summarize the parameters of the model and their effects on its behavior as follows:

- The total population N: As N increases, the model takes more steps (i.e. more time) on average to reach fixation. These extra steps limit the ability of a deleterious allele to make it just by pure chance, thus, as N increases, the probability of a deleterious allele to survive decreases.
- The initial population i, of the allele of interest, expressed relevant to N (e.g. N/2, N/4): As i decreases, the model will take fewer steps, at a given N, to reach fixation. In other words, starting with fewer As means the Bs will be faster in taking over.
- The fitness r of the deleterious allele: As r drops below 1 (i.e. A comes into disadvantage compared to B), the survival rate of A rapidly diminishes. In other words, deleterious alleles with a slight disadvantage may survive, but considerable disadvantages will almost certainly lead to extinction.

The simulations run above are limited by computational capacity to a finite number of runs for each experiment. It should thus be taken into account that, in theory, there is always the possibility, no matter how small, that a deleterious allele survives.


\newpage
\thispagestyle{empty}


# REFERENCES

NOWAK, M. A. (2006). *Evolutionary Dynamics: Exploring the Equations of Life.* Harvard University Press. https://doi.org/10.2307/j.ctvjghw98


todo: Add titles to diagrams?
