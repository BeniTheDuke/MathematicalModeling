---
title: "Moran Simulation"
author: "Eleni Karfopoulou & Benjamin Herzog"
format:
  html:
    toc: true
    number-sections: true
  pdf:
    number-sections: true
execute:
  echo: true
  warning: false
  message: false
---
```{python}
#| echo: false
#| include: false

import numpy as np
from moran import MoranModel
import matplotlib.pyplot as plt

```

# The Moran model: Fixation time of beneficial alleles in populations of constant size

### *(1) Formally define the Moran model of population dynamics with selection. List model’s assumptions. What is the probability of fixation of an allele, how does it depend on allele fitness? Write a program to simulate a population with selection.*

The Moran model is a birth-death Markov model used to study population dynamics in biology. In this particular model we study the distribution of alleles across generations when there is selection, i.e. a particular allele presents with increased (or decreased) fitness that affects its probability for reproduction, as opposed to the neutral drift model, when alleles reproduce at the same rate. Chapter 6 of *Nowak, 2006* is used as reference.

#### Model assumptions:

-   The size of the population, *N*, is fixed.

-   There are two types of alleles of interest in the population, A and B. (For ease of reference, we will refer to the individuals -carrying those alleles- as A and B.)

-   [At every one time step]{.underline}, one random individual from the population is chosen to reproduce and one random individual is chosen to die. Sampling with replacement applies, i.e. it could be the same individual chosen for reproduction as well as death.

-   Reproduction leads to A producing A, and B producing B.

-   In a Moran model with selection, A has fitness *r* and B has fitness 1. If *r* \> 1, selection favors A; if *r* \< 1, selection favors B. (When *r* = 1, this is the case of neutral drift.)

#### Model description:

-   The number of A individuals in the population is denoted *i*, and the number of B individuals is thus *N - i*. The state space of *i* is 0, …., *N*.

-   The probability of choosing an A individual for reproduction is *(r \* i) / \[r \* i + (N - i ) \* 1\] = (r \* i) / (r \* i + N - i)*.

-   The probability of choosing B for reproduction is *(N - i) / (r \* i + N - i)*.

-   The probability of choosing an A individual for death is *i/N*, for a B individual it is *(N - i)/N*.

-   In every time step there are four possible scenarios:

    -   With probability *\[(r \* i) / (r \* i + N - i)\] \* (i/N)*, an A is chosen for birth as well as death; *i* remains unchanged.

    -   With probability *\[(N - i) / (r \* i + N - i)\] \* (N - i)/N*, a B is chosen for birth as well as death; *i* remains unchanged.

    -   With probability *\[(r \* i) / (r \* i + N - i)\] \* (N - i)/N*, an A is chosen for birth and a B for death; *i* becomes *i + 1*.

    -   With probability *\[(N - i) / (r \* i + N - i)\] \* i/N*, a B is chosen for birth and an A for death; *i* becomes *i - 1*.

<!-- -->

-   The transition matrix from state *i* to state *j* is accordingly described by

    -   P~i, i-1~ = *\[(N - i) / (r \* i + N - i)\] \* i/N*

    -   P~i, i~ = *1 - P~i, i-1~ - P~i, i+1~*

    -   P~i, i+1~ = *\[(r \* i) / (r \* i + N - i)\] \* (N - i)/N*

-   No other transition is possible, thus all other entries are 0. Also, P~0, 0~ = 1, P~0, i~ = 0, P~N, N~ = 1 and P~N, 0~ = 0, i.e. 0 and *N* are absorbing states.

The **fixation probability** of A refers to the probability of reaching a state where *i = N*, i.e. A has overtaken the entire population. In this model with selection, with the relative fitness of A being *r*, the fixation probability, starting from *i* individuals of A, is:

χ~i~ = (1 - 1/r^i^) / (1 - 1/r^N^)

-   If there is no selective advantage, starting with *i* individuals of A, the probability of A overtaking the entire *N* population is *i/N*.

-   If *r* \>1 in a large population *N*, the denominator approaches 1 and the equation approximates 1 - 1/r^i.^

-   If *r* \< 1, the nominator approaches 0 as *r* gets smaller.

#### Model simulation:

The below program simulates a Moran population model with selection.

```{python}
SEED = 42

moran_model = MoranModel(100, 50, 1, 1, SEED)
for i in range(1,10):
    print(moran_model.run_until_absorption()[-1])


```

### *(2) Validate your program in simple simulation, show the results of validation.*

In a neutral model where fitness = 1 for both alleles, the fixation probability is i/N. If we run the model for 1000 runs, for N = 100, for different i, the number of times the end state of i is 100 should approximate i/N, as shown in the code below:

```{python}
N = 100
n_of_experiments = 10 #todo change back to 1000


observed_probs = []
calculated_probs = []
i_list = range(0,101,10)

for i in i_list:
  moran_model = MoranModel(N, i, 1, 1, SEED)
  fix_prob = i/N
  count=[] # list of the end states of i
  for run in range(n_of_experiments):
    count.append(moran_model.run_until_absorption()[-1])
    obs_fix = (count.count(100))/n_of_experiments
  
  
  calculated_probs.append(fix_prob)
  observed_probs.append(obs_fix)
  
w = 0.3 # Width 
x = np.arange(len(i_list))
plt.figure()
plt.bar(x - w/2, calculated_probs, width=w, label="Calculated")
plt.bar(x + w/2, observed_probs, width=w, label="Simulated")
plt.xlabel("N")
plt.ylabel("Result")
plt.xticks(x, i_list)
plt.legend()
plt.tight_layout()
plt.show()

```

Accordingly, the code below checks whether the observed fixation rate matches the expected fixation probability for different values r of fitness of A:

```{python}
N = 100
n_of_experiments = 10 #todo change back to 1000

observed_probs = []
calculated_probs = []
i_list = range(10,91,10)
r_list = np.arange(0.2,2.1,0.4)

for i in i_list:
  for r in r_list:
    
    moran_model = MoranModel(N, i, r, 1, SEED)
    
    if r == 1:
      fix_prob = i/N
    else:
      fix_prob = (1 - 1/r**i)/(1 - 1/r**N)
    
    count=[] # list of the end states of i
    
    for run in range(n_of_experiments):
      count.append(moran_model.run_until_absorption()[-1])
    obs_fix = (count.count(100))/n_of_experiments

    calculated_probs.append(fix_prob)
    observed_probs.append(obs_fix)

calculated_probs = np.array(calculated_probs)
observed_probs   = np.array(observed_probs)

x = np.arange(len(calculated_probs))  
w = 0.35

plt.figure(figsize=(12, 4))
plt.bar(x - w/2, calculated_probs, width=w, label="Calculated")
plt.bar(x + w/2, observed_probs,   width=w, label="Simulated")

plt.xlabel("")
plt.xticks([])
plt.tick_params(axis="x", bottom=False)
plt.ylabel("Result")
plt.legend()
plt.tight_layout()
plt.show() 

```


TODO: Note that the ones with 0.2 and 0.6 are always 0 or almost 0. Should we skip them? Also think about the two higher ones.

### *(3) Use your program to simulate data over time with and without selection for different population sizes. Vary the selection intensity to include a range of different values (both negative and positive selection). Summarize your results graphically. Is selection more efficient in smaller or larger populations? Can deleterious alleles (with negative selection coefficient) get fixed in a population? Under which conditions?*

### *(4) The Moran model is a birth-death model. How do the birth-death parameters influence the behavior of the model? Show in simulation. Discuss your results.*

## REFERENCES

NOWAK, M. A. (2006). *Evolutionary Dynamics: Exploring the Equations of Life.* Harvard University Press. https://doi.org/10.2307/j.ctvjghw98
